<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/gestion-stock/src/test/java/com/tricol/gestionstock/service/BonSortieServiceFifoTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gestion-stock/src/test/java/com/tricol/gestionstock/service/BonSortieServiceFifoTest.java" />
              <option name="originalContent" value="package com.tricol.gestionstock.service;&#10;&#10;import com.tricol.gestionstock.dto.bonsortie.BonSortieResponseDTO;&#10;import com.tricol.gestionstock.entity.*;&#10;import com.tricol.gestionstock.entity.Enums.MotifSortie;&#10;import com.tricol.gestionstock.entity.Enums.StatutBonSortie;&#10;import com.tricol.gestionstock.mapper.BonSortieMapper;&#10;import com.tricol.gestionstock.repository.*;&#10;import com.tricol.gestionstock.service.impl.BonSortieServiceImpl;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.ArgumentCaptor;&#10;import org.mockito.Captor;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDate;&#10;import java.util.ArrayList;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.ArgumentMatchers.anyLong;&#10;import static org.mockito.Mockito.*;&#10;import static org.mockito.Mockito.lenient;&#10;&#10;/**&#10; * Tests unitaires pour la logique FIFO de gestion de stock&#10; * Partie 1 : Tests Unitaires de la Gestion de Stock&#10; */&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot;Tests FIFO - Bon de Sortie Service&quot;)&#10;class BonSortieServiceFifoTest {&#10;&#10;    @Mock&#10;    private BonSortieRepository bonSortieRepository;&#10;&#10;    @Mock&#10;    private ProduitRepository produitRepository;&#10;&#10;    @Mock&#10;    private LotStockRepository lotStockRepository;&#10;&#10;    @Mock&#10;    private MouvementStockRepository mouvementStockRepository;&#10;&#10;    @Mock&#10;    private BonSortieMapper mapper;&#10;&#10;    @InjectMocks&#10;    private BonSortieServiceImpl bonSortieService;&#10;&#10;    @Captor&#10;    private ArgumentCaptor&lt;LotStock&gt; lotStockCaptor;&#10;&#10;    @Captor&#10;    private ArgumentCaptor&lt;MouvementStock&gt; mouvementStockCaptor;&#10;&#10;    @Captor&#10;    private ArgumentCaptor&lt;Produit&gt; produitCaptor;&#10;&#10;    private Produit produit;&#10;    private BonSortie bonSortie;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Initialisation du produit de test&#10;        produit = Produit.builder()&#10;                .id(1L)&#10;                .reference(&quot;PROD-001&quot;)&#10;                .nom(&quot;Produit Test&quot;)&#10;                .stockActuel(100)&#10;                .pointDeCommande(10)&#10;                .build();&#10;&#10;        // Initialisation du bon de sortie&#10;        bonSortie = BonSortie.builder()&#10;                .id(1L)&#10;                .numeroBon(&quot;BS-2024-001&quot;)&#10;                .dateSortie(LocalDate.now())&#10;                .atelierDestinataire(&quot;Atelier A&quot;)&#10;                .motif(MotifSortie.PRODUCTION)&#10;                .statut(StatutBonSortie.BROUILLON)&#10;                .lignes(new ArrayList&lt;&gt;())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * SCENARIO 1 : Sortie simple consommant partiellement un seul lot&#10;     * - Un seul lot avec 50 unités&#10;     * - Demande de sortie de 30 unités&#10;     * - Le lot doit avoir 20 unités restantes après consommation&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Scenario 1: Sortie partielle d'un seul lot&quot;)&#10;    void testSortiePartielleUnSeulLot() {&#10;        // ARRANGE&#10;        int quantiteLot = 50;&#10;        int quantiteDemandee = 30;&#10;        int quantiteAttendue = quantiteLot - quantiteDemandee; // 20&#10;&#10;        // Création du lot le plus ancien&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(10), quantiteLot, new BigDecimal(&quot;10.00&quot;));&#10;&#10;        // Configuration des mocks&#10;        configurerMocksValidation(produit, bonSortie, List.of(lot1), quantiteDemandee);&#10;&#10;        // ACT&#10;        BonSortieResponseDTO result = bonSortieService.validerBonSortie(1L);&#10;&#10;        // ASSERT&#10;        assertNotNull(result, &quot;Le résultat ne doit pas être null&quot;);&#10;&#10;        // Vérifier que le lot a été consommé correctement&#10;        verify(lotStockRepository, times(1)).save(lotStockCaptor.capture());&#10;        LotStock lotSauvegarde = lotStockCaptor.getValue();&#10;        assertEquals(quantiteAttendue, lotSauvegarde.getQuantiteRestante(),&#10;                &quot;Le lot doit avoir &quot; + quantiteAttendue + &quot; unités restantes&quot;);&#10;&#10;        // Vérifier qu'un seul mouvement de stock a été créé&#10;        verify(mouvementStockRepository, times(1)).save(any(MouvementStock.class));&#10;&#10;        // Vérifier que le stock du produit a été décrémenté&#10;        verify(produitRepository, times(1)).save(produitCaptor.capture());&#10;        Produit produitSauvegarde = produitCaptor.getValue();&#10;        assertEquals(100 - quantiteDemandee, produitSauvegarde.getStockActuel(),&#10;                &quot;Le stock du produit doit être réduit de &quot; + quantiteDemandee);&#10;    }&#10;&#10;    /**&#10;     * SCENARIO 2 : Sortie nécessitant la consommation de plusieurs lots successifs&#10;     * - Lot 1 (le plus ancien) : 30 unités&#10;     * - Lot 2 (moyen) : 40 unités&#10;     * - Lot 3 (le plus récent) : 50 unités&#10;     * - Demande de sortie de 60 unités&#10;     * - Lot 1 doit être épuisé (0 unités)&#10;     * - Lot 2 doit avoir 10 unités restantes&#10;     * - Lot 3 ne doit pas être touché (50 unités)&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Scenario 2: Sortie consommant plusieurs lots successifs (FIFO)&quot;)&#10;    void testSortiePlusieursLotsFifo() {&#10;        // ARRANGE&#10;        int quantiteDemandee = 60;&#10;&#10;        // Création de 3 lots (du plus ancien au plus récent)&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(30), 30, new BigDecimal(&quot;10.00&quot;));&#10;        LotStock lot2 = creerLot(2L, &quot;LOT-002&quot;, LocalDate.now().minusDays(20), 40, new BigDecimal(&quot;11.00&quot;));&#10;        LotStock lot3 = creerLot(3L, &quot;LOT-003&quot;, LocalDate.now().minusDays(10), 50, new BigDecimal(&quot;12.00&quot;));&#10;&#10;        produit.setStockActuel(120); // Total des 3 lots&#10;&#10;        // Configuration des mocks&#10;        configurerMocksValidation(produit, bonSortie, Arrays.asList(lot1, lot2, lot3), quantiteDemandee);&#10;&#10;        // ACT&#10;        BonSortieResponseDTO result = bonSortieService.validerBonSortie(1L);&#10;&#10;        // ASSERT&#10;        assertNotNull(result);&#10;&#10;        // Vérifier que 2 lots ont été sauvegardés (lot1 et lot2)&#10;        verify(lotStockRepository, times(2)).save(lotStockCaptor.capture());&#10;        List&lt;LotStock&gt; lotsSauvegardes = lotStockCaptor.getAllValues();&#10;&#10;        // Vérifier lot 1 : complètement épuisé&#10;        LotStock lot1Sauvegarde = lotsSauvegardes.get(0);&#10;        assertEquals(0, lot1Sauvegarde.getQuantiteRestante(),&#10;                &quot;Le lot 1 (le plus ancien) doit être complètement épuisé&quot;);&#10;&#10;        // Vérifier lot 2 : partiellement consommé (40 - 30 = 10)&#10;        LotStock lot2Sauvegarde = lotsSauvegardes.get(1);&#10;        assertEquals(10, lot2Sauvegarde.getQuantiteRestante(),&#10;                &quot;Le lot 2 doit avoir 10 unités restantes&quot;);&#10;&#10;        // Vérifier que 2 mouvements de stock ont été créés (un par lot consommé)&#10;        verify(mouvementStockRepository, times(2)).save(mouvementStockCaptor.capture());&#10;        List&lt;MouvementStock&gt; mouvements = mouvementStockCaptor.getAllValues();&#10;&#10;        // Vérifier les quantités des mouvements&#10;        assertEquals(30, mouvements.get(0).getQuantite(), &quot;Le premier mouvement doit être de 30 unités&quot;);&#10;        assertEquals(30, mouvements.get(1).getQuantite(), &quot;Le deuxième mouvement doit être de 30 unités&quot;);&#10;&#10;        // Vérifier que le stock du produit a été décrémenté&#10;        verify(produitRepository, times(1)).save(produitCaptor.capture());&#10;        assertEquals(60, produitCaptor.getValue().getStockActuel(),&#10;                &quot;Le stock du produit doit être réduit de 60&quot;);&#10;    }&#10;&#10;    /**&#10;     * SCENARIO 3 : Sortie avec stock insuffisant (gestion d'erreur)&#10;     * - Stock disponible : 40 unités&#10;     * - Demande de sortie : 50 unités&#10;     * - Doit lever une exception IllegalStateException&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Scenario 3: Stock insuffisant - Exception attendue&quot;)&#10;    void testStockInsuffisant() {&#10;        // ARRANGE&#10;        int stockDisponible = 40;&#10;        int quantiteDemandee = 50;&#10;&#10;        produit.setStockActuel(stockDisponible);&#10;&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now(), stockDisponible, new BigDecimal(&quot;10.00&quot;));&#10;&#10;        // Configuration des mocks&#10;        configurerMocksValidation(produit, bonSortie, List.of(lot1), quantiteDemandee);&#10;&#10;        // ACT &amp; ASSERT&#10;        IllegalStateException exception = assertThrows(IllegalStateException.class,&#10;                () -&gt; bonSortieService.validerBonSortie(1L),&#10;                &quot;Une exception doit être levée pour stock insuffisant&quot;);&#10;&#10;        assertTrue(exception.getMessage().contains(&quot;Stock insuffisant&quot;),&#10;                &quot;Le message d'erreur doit mentionner le stock insuffisant&quot;);&#10;&#10;        // Vérifier qu'aucun lot n'a été sauvegardé&#10;        verify(lotStockRepository, never()).save(any(LotStock.class));&#10;&#10;        // Vérifier qu'aucun mouvement n'a été créé&#10;        verify(mouvementStockRepository, never()).save(any(MouvementStock.class));&#10;&#10;        // Vérifier que le produit n'a pas été modifié&#10;        verify(produitRepository, never()).save(any(Produit.class));&#10;    }&#10;&#10;    /**&#10;     * SCENARIO 4 : Sortie épuisant exactement le stock disponible&#10;     * - Lot 1 : 30 unités&#10;     * - Lot 2 : 20 unités&#10;     * - Demande de sortie : 50 unités (exactement le total)&#10;     * - Les deux lots doivent être épuisés (0 unités chacun)&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Scenario 4: Sortie épuisant exactement le stock&quot;)&#10;    void testSortieEpuisantExactementLeStock() {&#10;        // ARRANGE&#10;        int quantiteDemandee = 50;&#10;&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(20), 30, new BigDecimal(&quot;10.00&quot;));&#10;        LotStock lot2 = creerLot(2L, &quot;LOT-002&quot;, LocalDate.now().minusDays(10), 20, new BigDecimal(&quot;11.00&quot;));&#10;&#10;        produit.setStockActuel(50);&#10;&#10;        // Configuration des mocks&#10;        configurerMocksValidation(produit, bonSortie, Arrays.asList(lot1, lot2), quantiteDemandee);&#10;&#10;        // ACT&#10;        BonSortieResponseDTO result = bonSortieService.validerBonSortie(1L);&#10;&#10;        // ASSERT&#10;        assertNotNull(result);&#10;&#10;        // Vérifier que les 2 lots ont été sauvegardés&#10;        verify(lotStockRepository, times(2)).save(lotStockCaptor.capture());&#10;        List&lt;LotStock&gt; lotsSauvegardes = lotStockCaptor.getAllValues();&#10;&#10;        // Vérifier que les deux lots sont épuisés&#10;        assertEquals(0, lotsSauvegardes.get(0).getQuantiteRestante(),&#10;                &quot;Le lot 1 doit être complètement épuisé&quot;);&#10;        assertEquals(0, lotsSauvegardes.get(1).getQuantiteRestante(),&#10;                &quot;Le lot 2 doit être complètement épuisé&quot;);&#10;&#10;        // Vérifier que les deux lots sont marqués comme épuisés&#10;        assertTrue(lotsSauvegardes.get(0).isEpuise(), &quot;Le lot 1 doit être marqué comme épuisé&quot;);&#10;        assertTrue(lotsSauvegardes.get(1).isEpuise(), &quot;Le lot 2 doit être marqué comme épuisé&quot;);&#10;&#10;        // Vérifier que 2 mouvements ont été créés&#10;        verify(mouvementStockRepository, times(2)).save(mouvementStockCaptor.capture());&#10;        List&lt;MouvementStock&gt; mouvements = mouvementStockCaptor.getAllValues();&#10;&#10;        assertEquals(30, mouvements.get(0).getQuantite());&#10;        assertEquals(20, mouvements.get(1).getQuantite());&#10;&#10;        // Vérifier que le stock du produit est à 0&#10;        verify(produitRepository, times(1)).save(produitCaptor.capture());&#10;        assertEquals(0, produitCaptor.getValue().getStockActuel(),&#10;                &quot;Le stock du produit doit être à 0&quot;);&#10;    }&#10;&#10;    // ========== MÉTHODES UTILITAIRES ==========&#10;&#10;    /**&#10;     * Crée un lot de stock pour les tests&#10;     */&#10;    private LotStock creerLot(Long id, String numeroLot, LocalDate dateEntree,&#10;                              int quantite, BigDecimal prixUnitaire) {&#10;        return LotStock.builder()&#10;                .id(id)&#10;                .numeroLot(numeroLot)&#10;                .produit(produit)&#10;                .dateEntree(dateEntree)&#10;                .quantiteInitiale(quantite)&#10;                .quantiteRestante(quantite)&#10;                .prixAchatUnitaire(prixUnitaire)&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Configure les mocks pour la validation d'un bon de sortie&#10;     */&#10;    private void configurerMocksValidation(Produit produit, BonSortie bonSortie,&#10;                                           List&lt;LotStock&gt; lots, int quantiteDemandee) {&#10;        // Créer une ligne de bon de sortie&#10;        LigneBonSortie ligne = LigneBonSortie.builder()&#10;                .id(1L)&#10;                .produit(produit)&#10;                .quantiteDemandee(quantiteDemandee)&#10;                .build();&#10;        bonSortie.getLignes().add(ligne);&#10;&#10;        // Configuration des mocks (use lenient for cases where exception might prevent some mocks from being called)&#10;        lenient().when(bonSortieRepository.findByIdWithLignes(anyLong())).thenReturn(Optional.of(bonSortie));&#10;        lenient().when(lotStockRepository.findLotsDisponiblesByProduitFIFO(produit.getId())).thenReturn(lots);&#10;        lenient().when(lotStockRepository.save(any(LotStock.class))).thenAnswer(invocation -&gt; invocation.getArgument(0));&#10;        lenient().when(mouvementStockRepository.save(any(MouvementStock.class))).thenAnswer(invocation -&gt; invocation.getArgument(0));&#10;        lenient().when(produitRepository.save(any(Produit.class))).thenAnswer(invocation -&gt; invocation.getArgument(0));&#10;        lenient().when(bonSortieRepository.save(any(BonSortie.class))).thenReturn(bonSortie);&#10;        lenient().when(mapper.toResponseDTO(any(BonSortie.class))).thenReturn(new BonSortieResponseDTO());&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.tricol.gestionstock.service;&#10;&#10;import com.tricol.gestionstock.dto.bonsortie.BonSortieResponseDTO;&#10;import com.tricol.gestionstock.entity.*;&#10;import com.tricol.gestionstock.entity.Enums.MotifSortie;&#10;import com.tricol.gestionstock.entity.Enums.StatutBonSortie;&#10;import com.tricol.gestionstock.mapper.BonSortieMapper;&#10;import com.tricol.gestionstock.repository.*;&#10;import com.tricol.gestionstock.service.impl.BonSortieServiceImpl;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.ArgumentCaptor;&#10;import org.mockito.Captor;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDate;&#10;import java.util.ArrayList;&#10;import java.util.Arrays;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.ArgumentMatchers.anyLong;&#10;import static org.mockito.Mockito.*;&#10;import static org.mockito.Mockito.lenient;&#10;&#10;/**&#10; * Tests unitaires pour la logique FIFO de gestion de stock&#10; * Partie 1 : Tests Unitaires de la Gestion de Stock&#10; */&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot;Tests FIFO - Bon de Sortie Service&quot;)&#10;class BonSortieServiceFifoTest {&#10;&#10;    @Mock&#10;    private BonSortieRepository bonSortieRepository;&#10;&#10;    @Mock&#10;    private ProduitRepository produitRepository;&#10;&#10;    @Mock&#10;    private LotStockRepository lotStockRepository;&#10;&#10;    @Mock&#10;    private MouvementStockRepository mouvementStockRepository;&#10;&#10;    @Mock&#10;    private BonSortieMapper mapper;&#10;&#10;    @InjectMocks&#10;    private BonSortieServiceImpl bonSortieService;&#10;&#10;    @Captor&#10;    private ArgumentCaptor&lt;LotStock&gt; lotStockCaptor;&#10;&#10;    @Captor&#10;    private ArgumentCaptor&lt;MouvementStock&gt; mouvementStockCaptor;&#10;&#10;    @Captor&#10;    private ArgumentCaptor&lt;Produit&gt; produitCaptor;&#10;&#10;    private Produit produit;&#10;    private BonSortie bonSortie;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        // Initialisation du produit de test&#10;        produit = Produit.builder()&#10;                .id(1L)&#10;                .reference(&quot;PROD-001&quot;)&#10;                .nom(&quot;Produit Test&quot;)&#10;                .stockActuel(100)&#10;                .pointDeCommande(10)&#10;                .build();&#10;&#10;        // Initialisation du bon de sortie&#10;        bonSortie = BonSortie.builder()&#10;                .id(1L)&#10;                .numeroBon(&quot;BS-2024-001&quot;)&#10;                .dateSortie(LocalDate.now())&#10;                .atelierDestinataire(&quot;Atelier A&quot;)&#10;                .motif(MotifSortie.PRODUCTION)&#10;                .statut(StatutBonSortie.BROUILLON)&#10;                .lignes(new ArrayList&lt;&gt;())&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * SCENARIO 1 : Sortie simple consommant partiellement un seul lot&#10;     * - Un seul lot avec 50 unités&#10;     * - Demande de sortie de 30 unités&#10;     * - Le lot doit avoir 20 unités restantes après consommation&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Scenario 1: Sortie partielle d'un seul lot&quot;)&#10;    void testSortiePartielleUnSeulLot() {&#10;        // ARRANGE&#10;        int quantiteLot = 50;&#10;        int quantiteDemandee = 30;&#10;        int quantiteAttendue = quantiteLot - quantiteDemandee; // 20&#10;&#10;        // Création du lot le plus ancien&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(10), quantiteLot, new BigDecimal(&quot;10.00&quot;));&#10;&#10;        // Configuration des mocks&#10;        configurerMocksValidation(produit, bonSortie, List.of(lot1), quantiteDemandee);&#10;&#10;        // ACT&#10;        BonSortieResponseDTO result = bonSortieService.validerBonSortie(1L);&#10;&#10;        // ASSERT&#10;        assertNotNull(result, &quot;Le résultat ne doit pas être null&quot;);&#10;&#10;        // Vérifier que le lot a été consommé correctement&#10;        verify(lotStockRepository, times(1)).save(lotStockCaptor.capture());&#10;        LotStock lotSauvegarde = lotStockCaptor.getValue();&#10;        assertEquals(quantiteAttendue, lotSauvegarde.getQuantiteRestante(),&#10;                &quot;Le lot doit avoir &quot; + quantiteAttendue + &quot; unités restantes&quot;);&#10;&#10;        // Vérifier qu'un seul mouvement de stock a été créé&#10;        verify(mouvementStockRepository, times(1)).save(any(MouvementStock.class));&#10;&#10;        // Vérifier que le stock du produit a été décrémenté&#10;        verify(produitRepository, times(1)).save(produitCaptor.capture());&#10;        Produit produitSauvegarde = produitCaptor.getValue();&#10;        assertEquals(100 - quantiteDemandee, produitSauvegarde.getStockActuel(),&#10;                &quot;Le stock du produit doit être réduit de &quot; + quantiteDemandee);&#10;    }&#10;&#10;    /**&#10;     * SCENARIO 2 : Sortie nécessitant la consommation de plusieurs lots successifs&#10;     * - Lot 1 (le plus ancien) : 30 unités&#10;     * - Lot 2 (moyen) : 40 unités&#10;     * - Lot 3 (le plus récent) : 50 unités&#10;     * - Demande de sortie de 60 unités&#10;     * - Lot 1 doit être épuisé (0 unités)&#10;     * - Lot 2 doit avoir 10 unités restantes&#10;     * - Lot 3 ne doit pas être touché (50 unités)&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Scenario 2: Sortie consommant plusieurs lots successifs (FIFO)&quot;)&#10;    void testSortiePlusieursLotsFifo() {&#10;        // ARRANGE&#10;        int quantiteDemandee = 60;&#10;&#10;        // Création de 3 lots (du plus ancien au plus récent)&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(30), 30, new BigDecimal(&quot;10.00&quot;));&#10;        LotStock lot2 = creerLot(2L, &quot;LOT-002&quot;, LocalDate.now().minusDays(20), 40, new BigDecimal(&quot;11.00&quot;));&#10;        LotStock lot3 = creerLot(3L, &quot;LOT-003&quot;, LocalDate.now().minusDays(10), 50, new BigDecimal(&quot;12.00&quot;));&#10;&#10;        produit.setStockActuel(120); // Total des 3 lots&#10;&#10;        // Configuration des mocks&#10;        configurerMocksValidation(produit, bonSortie, Arrays.asList(lot1, lot2, lot3), quantiteDemandee);&#10;&#10;        // ACT&#10;        BonSortieResponseDTO result = bonSortieService.validerBonSortie(1L);&#10;&#10;        // ASSERT&#10;        assertNotNull(result);&#10;&#10;        // Vérifier que 2 lots ont été sauvegardés (lot1 et lot2)&#10;        verify(lotStockRepository, times(2)).save(lotStockCaptor.capture());&#10;        List&lt;LotStock&gt; lotsSauvegardes = lotStockCaptor.getAllValues();&#10;&#10;        // Vérifier lot 1 : complètement épuisé&#10;        LotStock lot1Sauvegarde = lotsSauvegardes.get(0);&#10;        assertEquals(0, lot1Sauvegarde.getQuantiteRestante(),&#10;                &quot;Le lot 1 (le plus ancien) doit être complètement épuisé&quot;);&#10;&#10;        // Vérifier lot 2 : partiellement consommé (40 - 30 = 10)&#10;        LotStock lot2Sauvegarde = lotsSauvegardes.get(1);&#10;        assertEquals(10, lot2Sauvegarde.getQuantiteRestante(),&#10;                &quot;Le lot 2 doit avoir 10 unités restantes&quot;);&#10;&#10;        // Vérifier que 2 mouvements de stock ont été créés (un par lot consommé)&#10;        verify(mouvementStockRepository, times(2)).save(mouvementStockCaptor.capture());&#10;        List&lt;MouvementStock&gt; mouvements = mouvementStockCaptor.getAllValues();&#10;&#10;        // Vérifier les quantités des mouvements&#10;        assertEquals(30, mouvements.get(0).getQuantite(), &quot;Le premier mouvement doit être de 30 unités&quot;);&#10;        assertEquals(30, mouvements.get(1).getQuantite(), &quot;Le deuxième mouvement doit être de 30 unités&quot;);&#10;&#10;        // Vérifier que le stock du produit a été décrémenté&#10;        verify(produitRepository, times(1)).save(produitCaptor.capture());&#10;        assertEquals(60, produitCaptor.getValue().getStockActuel(),&#10;                &quot;Le stock du produit doit être réduit de 60&quot;);&#10;    }&#10;&#10;    /**&#10;     * SCENARIO 3 : Sortie avec stock insuffisant (gestion d'erreur)&#10;     * - Stock disponible : 40 unités&#10;     * - Demande de sortie : 50 unités&#10;     * - Doit lever une exception IllegalStateException&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Scenario 3: Stock insuffisant - Exception attendue&quot;)&#10;    void testStockInsuffisant() {&#10;        // ARRANGE&#10;        int stockDisponible = 40;&#10;        int quantiteDemandee = 50;&#10;&#10;        produit.setStockActuel(stockDisponible);&#10;&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now(), stockDisponible, new BigDecimal(&quot;10.00&quot;));&#10;&#10;        // Configuration des mocks&#10;        configurerMocksValidation(produit, bonSortie, List.of(lot1), quantiteDemandee);&#10;&#10;        // ACT &amp; ASSERT&#10;        IllegalStateException exception = assertThrows(IllegalStateException.class,&#10;                () -&gt; bonSortieService.validerBonSortie(1L),&#10;                &quot;Une exception doit être levée pour stock insuffisant&quot;);&#10;&#10;        assertTrue(exception.getMessage().contains(&quot;Stock insuffisant&quot;),&#10;                &quot;Le message d'erreur doit mentionner le stock insuffisant&quot;);&#10;&#10;        // Vérifier qu'aucun lot n'a été sauvegardé&#10;        verify(lotStockRepository, never()).save(any(LotStock.class));&#10;&#10;        // Vérifier qu'aucun mouvement n'a été créé&#10;        verify(mouvementStockRepository, never()).save(any(MouvementStock.class));&#10;&#10;        // Vérifier que le produit n'a pas été modifié&#10;        verify(produitRepository, never()).save(any(Produit.class));&#10;    }&#10;&#10;    /**&#10;     * SCENARIO 4 : Sortie épuisant exactement le stock disponible&#10;     * - Lot 1 : 30 unités&#10;     * - Lot 2 : 20 unités&#10;     * - Demande de sortie : 50 unités (exactement le total)&#10;     * - Les deux lots doivent être épuisés (0 unités chacun)&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Scenario 4: Sortie épuisant exactement le stock&quot;)&#10;    void testSortieEpuisantExactementLeStock() {&#10;        // ARRANGE&#10;        int quantiteDemandee = 50;&#10;&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(20), 30, new BigDecimal(&quot;10.00&quot;));&#10;        LotStock lot2 = creerLot(2L, &quot;LOT-002&quot;, LocalDate.now().minusDays(10), 20, new BigDecimal(&quot;11.00&quot;));&#10;&#10;        produit.setStockActuel(50);&#10;&#10;        // Configuration des mocks&#10;        configurerMocksValidation(produit, bonSortie, Arrays.asList(lot1, lot2), quantiteDemandee);&#10;&#10;        // ACT&#10;        BonSortieResponseDTO result = bonSortieService.validerBonSortie(1L);&#10;&#10;        // ASSERT&#10;        assertNotNull(result);&#10;&#10;        // Vérifier que les 2 lots ont été sauvegardés&#10;        verify(lotStockRepository, times(2)).save(lotStockCaptor.capture());&#10;        List&lt;LotStock&gt; lotsSauvegardes = lotStockCaptor.getAllValues();&#10;&#10;        // Vérifier que les deux lots sont épuisés&#10;        assertEquals(0, lotsSauvegardes.get(0).getQuantiteRestante(),&#10;                &quot;Le lot 1 doit être complètement épuisé&quot;);&#10;        assertEquals(0, lotsSauvegardes.get(1).getQuantiteRestante(),&#10;                &quot;Le lot 2 doit être complètement épuisé&quot;);&#10;&#10;        // Vérifier que les deux lots sont marqués comme épuisés&#10;        assertTrue(lotsSauvegardes.get(0).isEpuise(), &quot;Le lot 1 doit être marqué comme épuisé&quot;);&#10;        assertTrue(lotsSauvegardes.get(1).isEpuise(), &quot;Le lot 2 doit être marqué comme épuisé&quot;);&#10;&#10;        // Vérifier que 2 mouvements ont été créés&#10;        verify(mouvementStockRepository, times(2)).save(mouvementStockCaptor.capture());&#10;        List&lt;MouvementStock&gt; mouvements = mouvementStockCaptor.getAllValues();&#10;&#10;        assertEquals(30, mouvements.get(0).getQuantite());&#10;        assertEquals(20, mouvements.get(1).getQuantite());&#10;&#10;        // Vérifier que le stock du produit est à 0&#10;        verify(produitRepository, times(1)).save(produitCaptor.capture());&#10;        assertEquals(0, produitCaptor.getValue().getStockActuel(),&#10;                &quot;Le stock du produit doit être à 0&quot;);&#10;    }&#10;&#10;    /**&#10;     * SCENARIO 5 : Tests des Transitions de Statut&#10;     * Tâche 1.2 : Vérifier que la validation d'un bon de sortie déclenche les bonnes actions&#10;     * - Changement de statut de BROUILLON à VALIDÉ&#10;     * - Création des mouvements de stock&#10;     * - Mise à jour des quantités dans les lots&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Scenario 5: Validation change le statut de BROUILLON à VALIDÉ&quot;)&#10;    void testTransitionStatutBrouillonVersValide() {&#10;        // ARRANGE&#10;        int quantiteDemandee = 30;&#10;        &#10;        // Vérifier que le bon de sortie est en BROUILLON au départ&#10;        assertEquals(StatutBonSortie.BROUILLON, bonSortie.getStatut(),&#10;                &quot;Le bon de sortie doit être en statut BROUILLON avant validation&quot;);&#10;&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(10), 50, new BigDecimal(&quot;10.00&quot;));&#10;&#10;        // Configuration des mocks&#10;        configurerMocksValidation(produit, bonSortie, List.of(lot1), quantiteDemandee);&#10;&#10;        // ACT&#10;        BonSortieResponseDTO result = bonSortieService.validerBonSortie(1L);&#10;&#10;        // ASSERT&#10;        assertNotNull(result, &quot;Le résultat ne doit pas être null&quot;);&#10;&#10;        // Vérifier que le statut a changé&#10;        verify(bonSortieRepository, times(1)).save(any(BonSortie.class));&#10;        assertEquals(StatutBonSortie.VALIDE, bonSortie.getStatut(),&#10;                &quot;Le statut doit passer à VALIDE après validation&quot;);&#10;&#10;        // Vérifier que la date de validation a été enregistrée&#10;        assertNotNull(bonSortie.getDateValidation(),&#10;                &quot;La date de validation doit être enregistrée&quot;);&#10;        &#10;        // Vérifier que les mouvements ont été créés&#10;        verify(mouvementStockRepository, times(1)).save(any(MouvementStock.class));&#10;        &#10;        // Vérifier que les lots ont été mis à jour&#10;        verify(lotStockRepository, times(1)).save(any(LotStock.class));&#10;    }&#10;&#10;    /**&#10;     * SCENARIO 6 : Vérifier que les mouvements de stock créés sont correctement liés&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Scenario 6: Mouvements de stock sont correctement créés et liés&quot;)&#10;    void testMouvementsStockCorrectementLies() {&#10;        // ARRANGE&#10;        int quantiteDemandee = 40;&#10;        &#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(20), 30, new BigDecimal(&quot;10.00&quot;));&#10;        LotStock lot2 = creerLot(2L, &quot;LOT-002&quot;, LocalDate.now().minusDays(10), 50, new BigDecimal(&quot;11.00&quot;));&#10;&#10;        produit.setStockActuel(80);&#10;&#10;        // Configuration des mocks&#10;        configurerMocksValidation(produit, bonSortie, Arrays.asList(lot1, lot2), quantiteDemandee);&#10;&#10;        // ACT&#10;        bonSortieService.validerBonSortie(1L);&#10;&#10;        // ASSERT&#10;        verify(mouvementStockRepository, times(2)).save(mouvementStockCaptor.capture());&#10;        List&lt;MouvementStock&gt; mouvements = mouvementStockCaptor.getAllValues();&#10;&#10;        // Vérifier le premier mouvement (lot 1 - consommé complètement)&#10;        MouvementStock mouvement1 = mouvements.get(0);&#10;        assertEquals(30, mouvement1.getQuantite(), &quot;Le premier mouvement doit être de 30 unités&quot;);&#10;        assertEquals(produit, mouvement1.getProduit(), &quot;Le mouvement doit être lié au bon produit&quot;);&#10;        assertNotNull(mouvement1.getDateMouvement(), &quot;La date du mouvement doit être enregistrée&quot;);&#10;&#10;        // Vérifier le deuxième mouvement (lot 2 - partiellement consommé)&#10;        MouvementStock mouvement2 = mouvements.get(1);&#10;        assertEquals(10, mouvement2.getQuantite(), &quot;Le deuxième mouvement doit être de 10 unités&quot;);&#10;        assertEquals(produit, mouvement2.getProduit(), &quot;Le mouvement doit être lié au bon produit&quot;);&#10;    }&#10;&#10;    /**&#10;     * SCENARIO 7 : Vérifier que toutes les lignes du bon de sortie sont traitées&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Scenario 7: Toutes les lignes du bon de sortie sont traitées&quot;)&#10;    void testToutesLignesTraitees() {&#10;        // ARRANGE&#10;        int quantiteDemandee = 25;&#10;        &#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(10), 100, new BigDecimal(&quot;10.00&quot;));&#10;&#10;        // Configuration des mocks&#10;        configurerMocksValidation(produit, bonSortie, List.of(lot1), quantiteDemandee);&#10;&#10;        // ACT&#10;        BonSortieResponseDTO result = bonSortieService.validerBonSortie(1L);&#10;&#10;        // ASSERT&#10;        assertNotNull(result);&#10;        &#10;        // Vérifier que la ligne a été traitée&#10;        assertEquals(1, bonSortie.getLignes().size(), &quot;Le bon de sortie doit avoir une ligne&quot;);&#10;        LigneBonSortie ligne = bonSortie.getLignes().get(0);&#10;        assertEquals(quantiteDemandee, ligne.getQuantiteDemandee(),&#10;                &quot;La quantité demandée doit être celle de la ligne&quot;);&#10;        &#10;        // Vérifier que le stock a été décrémenté du bon montant&#10;        verify(produitRepository, times(1)).save(produitCaptor.capture());&#10;        Produit produitSauvegarde = produitCaptor.getValue();&#10;        assertEquals(100 - quantiteDemandee, produitSauvegarde.getStockActuel(),&#10;                &quot;Le stock doit être réduit de la quantité demandée&quot;);&#10;    }&#10;&#10;    // ========== MÉTHODES UTILITAIRES ==========&#10;&#10;    /**&#10;     * Crée un lot de stock pour les tests&#10;     */&#10;    private LotStock creerLot(Long id, String numeroLot, LocalDate dateEntree,&#10;                              int quantite, BigDecimal prixUnitaire) {&#10;        return LotStock.builder()&#10;                .id(id)&#10;                .numeroLot(numeroLot)&#10;                .produit(produit)&#10;                .dateEntree(dateEntree)&#10;                .quantiteInitiale(quantite)&#10;                .quantiteRestante(quantite)&#10;                .prixAchatUnitaire(prixUnitaire)&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * Configure les mocks pour la validation d'un bon de sortie&#10;     */&#10;    private void configurerMocksValidation(Produit produit, BonSortie bonSortie,&#10;                                           List&lt;LotStock&gt; lots, int quantiteDemandee) {&#10;        // Créer une ligne de bon de sortie&#10;        LigneBonSortie ligne = LigneBonSortie.builder()&#10;                .id(1L)&#10;                .produit(produit)&#10;                .quantiteDemandee(quantiteDemandee)&#10;                .build();&#10;        bonSortie.getLignes().add(ligne);&#10;&#10;        // Configuration des mocks (use lenient for cases where exception might prevent some mocks from being called)&#10;        lenient().when(bonSortieRepository.findByIdWithLignes(anyLong())).thenReturn(Optional.of(bonSortie));&#10;        lenient().when(lotStockRepository.findLotsDisponiblesByProduitFIFO(produit.getId())).thenReturn(lots);&#10;        lenient().when(lotStockRepository.save(any(LotStock.class))).thenAnswer(invocation -&gt; invocation.getArgument(0));&#10;        lenient().when(mouvementStockRepository.save(any(MouvementStock.class))).thenAnswer(invocation -&gt; invocation.getArgument(0));&#10;        lenient().when(produitRepository.save(any(Produit.class))).thenAnswer(invocation -&gt; invocation.getArgument(0));&#10;        lenient().when(bonSortieRepository.save(any(BonSortie.class))).thenReturn(bonSortie);&#10;        lenient().when(mapper.toResponseDTO(any(BonSortie.class))).thenReturn(new BonSortieResponseDTO());&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gestion-stock/src/test/java/com/tricol/gestionstock/service/StockServiceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gestion-stock/src/test/java/com/tricol/gestionstock/service/StockServiceTest.java" />
              <option name="updatedContent" value="package com.tricol.gestionstock.service;&#10;&#10;import com.tricol.gestionstock.entity.LotStock;&#10;import com.tricol.gestionstock.entity.Produit;&#10;import com.tricol.gestionstock.repository.LotStockRepository;&#10;import com.tricol.gestionstock.repository.ProduitRepository;&#10;import com.tricol.gestionstock.mapper.StockMapper;&#10;import com.tricol.gestionstock.service.impl.StockServiceImpl;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDate;&#10;import java.util.Arrays;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;/**&#10; * Tests unitaires pour la valorisation du stock selon la méthode FIFO&#10; * Tâche 1.1.C : Calcul de Valorisation du Stock&#10; */&#10;@ExtendWith(MockitoExtension.class)&#10;@DisplayName(&quot;Tests de Valorisation FIFO - Stock Service&quot;)&#10;class StockServiceTest {&#10;&#10;    @Mock&#10;    private ProduitRepository produitRepository;&#10;&#10;    @Mock&#10;    private LotStockRepository lotStockRepository;&#10;&#10;    @Mock&#10;    private StockMapper stockMapper;&#10;&#10;    @InjectMocks&#10;    private StockServiceImpl stockService;&#10;&#10;    private Produit produit;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        produit = Produit.builder()&#10;                .id(1L)&#10;                .reference(&quot;PROD-001&quot;)&#10;                .nom(&quot;Produit Test&quot;)&#10;                .stockActuel(100)&#10;                .pointDeCommande(10)&#10;                .build();&#10;    }&#10;&#10;    /**&#10;     * TEST 1 : Calcul de valorisation avec un seul lot&#10;     * Vérifie que la valorisation = quantité restante × prix unitaire&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Test 1: Valorisation d'un seul lot&quot;)&#10;    void testValorisationUnSeulLot() {&#10;        // ARRANGE&#10;        int quantiteRestante = 50;&#10;        BigDecimal prixUnitaire = new BigDecimal(&quot;10.00&quot;);&#10;        BigDecimal valorisationAttendue = new BigDecimal(&quot;500.00&quot;); // 50 × 10.00&#10;&#10;        LotStock lot = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now(), 50, quantiteRestante, prixUnitaire);&#10;&#10;        when(lotStockRepository.findAll()).thenReturn(List.of(lot));&#10;&#10;        // ACT&#10;        BigDecimal valorisation = stockService.getValorisationFifo();&#10;&#10;        // ASSERT&#10;        assertNotNull(valorisation, &quot;La valorisation ne doit pas être null&quot;);&#10;        assertEquals(0, valorisationAttendue.compareTo(valorisation),&#10;                &quot;La valorisation doit être de 500.00 (50 × 10.00)&quot;);&#10;&#10;        verify(lotStockRepository, times(1)).findAll();&#10;    }&#10;&#10;    /**&#10;     * TEST 2 : Calcul de valorisation avec plusieurs lots à prix différents&#10;     * Vérifie que la valorisation totale est la somme des valorisations de chaque lot&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Test 2: Valorisation avec plusieurs lots à prix différents&quot;)&#10;    void testValorisationPlusieursLotsPrixDifferents() {&#10;        // ARRANGE&#10;        // Lot 1: 30 unités × 10.00 = 300.00&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(30), 30, 30, new BigDecimal(&quot;10.00&quot;));&#10;        &#10;        // Lot 2: 40 unités × 11.50 = 460.00&#10;        LotStock lot2 = creerLot(2L, &quot;LOT-002&quot;, LocalDate.now().minusDays(20), 40, 40, new BigDecimal(&quot;11.50&quot;));&#10;        &#10;        // Lot 3: 50 unités × 12.00 = 600.00&#10;        LotStock lot3 = creerLot(3L, &quot;LOT-003&quot;, LocalDate.now().minusDays(10), 50, 50, new BigDecimal(&quot;12.00&quot;));&#10;&#10;        // Valorisation totale attendue = 300.00 + 460.00 + 600.00 = 1360.00&#10;        BigDecimal valorisationAttendue = new BigDecimal(&quot;1360.00&quot;);&#10;&#10;        when(lotStockRepository.findAll()).thenReturn(Arrays.asList(lot1, lot2, lot3));&#10;&#10;        // ACT&#10;        BigDecimal valorisation = stockService.getValorisationFifo();&#10;&#10;        // ASSERT&#10;        assertNotNull(valorisation);&#10;        assertEquals(0, valorisationAttendue.compareTo(valorisation),&#10;                &quot;La valorisation totale doit être de 1360.00 (300 + 460 + 600)&quot;);&#10;&#10;        verify(lotStockRepository, times(1)).findAll();&#10;    }&#10;&#10;    /**&#10;     * TEST 3 : Calcul de valorisation avec lots partiellement consommés&#10;     * Vérifie que seule la quantité restante est valorisée (FIFO)&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Test 3: Valorisation selon FIFO avec lots partiellement consommés&quot;)&#10;    void testValorisationFifoLotsPartiellementConsommes() {&#10;        // ARRANGE&#10;        // Lot 1 (le plus ancien): quantité initiale 100, restante 20 → 20 × 10.00 = 200.00&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(30), 100, 20, new BigDecimal(&quot;10.00&quot;));&#10;        &#10;        // Lot 2 (moyen): quantité initiale 80, restante 50 → 50 × 11.00 = 550.00&#10;        LotStock lot2 = creerLot(2L, &quot;LOT-002&quot;, LocalDate.now().minusDays(20), 80, 50, new BigDecimal(&quot;11.00&quot;));&#10;        &#10;        // Lot 3 (le plus récent): quantité initiale 60, restante 60 (non consommé) → 60 × 12.00 = 720.00&#10;        LotStock lot3 = creerLot(3L, &quot;LOT-003&quot;, LocalDate.now().minusDays(10), 60, 60, new BigDecimal(&quot;12.00&quot;));&#10;&#10;        // Valorisation attendue = 200.00 + 550.00 + 720.00 = 1470.00&#10;        BigDecimal valorisationAttendue = new BigDecimal(&quot;1470.00&quot;);&#10;&#10;        when(lotStockRepository.findAll()).thenReturn(Arrays.asList(lot1, lot2, lot3));&#10;&#10;        // ACT&#10;        BigDecimal valorisation = stockService.getValorisationFifo();&#10;&#10;        // ASSERT&#10;        assertNotNull(valorisation);&#10;        assertEquals(0, valorisationAttendue.compareTo(valorisation),&#10;                &quot;La valorisation doit être basée sur les quantités restantes (1470.00)&quot;);&#10;&#10;        verify(lotStockRepository, times(1)).findAll();&#10;    }&#10;&#10;    /**&#10;     * TEST 4 : Calcul de valorisation avec des lots complètement épuisés&#10;     * Vérifie que les lots épuisés ne sont pas comptabilisés&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Test 4: Lots épuisés ne sont pas valorisés&quot;)&#10;    void testValorisationLotsEpuises() {&#10;        // ARRANGE&#10;        // Lot 1: complètement épuisé (quantité restante = 0)&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(30), 100, 0, new BigDecimal(&quot;10.00&quot;));&#10;        &#10;        // Lot 2: partiellement consommé (quantité restante = 25)&#10;        LotStock lot2 = creerLot(2L, &quot;LOT-002&quot;, LocalDate.now().minusDays(20), 50, 25, new BigDecimal(&quot;12.00&quot;));&#10;        &#10;        // Lot 3: complètement épuisé (quantité restante = 0)&#10;        LotStock lot3 = creerLot(3L, &quot;LOT-003&quot;, LocalDate.now().minusDays(10), 75, 0, new BigDecimal(&quot;11.00&quot;));&#10;&#10;        // Valorisation attendue = 0 + (25 × 12.00) + 0 = 300.00&#10;        BigDecimal valorisationAttendue = new BigDecimal(&quot;300.00&quot;);&#10;&#10;        when(lotStockRepository.findAll()).thenReturn(Arrays.asList(lot1, lot2, lot3));&#10;&#10;        // ACT&#10;        BigDecimal valorisation = stockService.getValorisationFifo();&#10;&#10;        // ASSERT&#10;        assertNotNull(valorisation);&#10;        assertEquals(0, valorisationAttendue.compareTo(valorisation),&#10;                &quot;Seuls les lots avec quantité restante &gt; 0 doivent être valorisés (300.00)&quot;);&#10;&#10;        verify(lotStockRepository, times(1)).findAll();&#10;    }&#10;&#10;    /**&#10;     * TEST 5 : Calcul de valorisation avec stock vide&#10;     * Vérifie que la valorisation est zéro quand il n'y a pas de lots&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Test 5: Valorisation avec stock vide&quot;)&#10;    void testValorisationStockVide() {&#10;        // ARRANGE&#10;        when(lotStockRepository.findAll()).thenReturn(Collections.emptyList());&#10;&#10;        // ACT&#10;        BigDecimal valorisation = stockService.getValorisationFifo();&#10;&#10;        // ASSERT&#10;        assertNotNull(valorisation, &quot;La valorisation ne doit pas être null&quot;);&#10;        assertEquals(0, BigDecimal.ZERO.compareTo(valorisation),&#10;                &quot;La valorisation doit être zéro quand il n'y a pas de lots&quot;);&#10;&#10;        verify(lotStockRepository, times(1)).findAll();&#10;    }&#10;&#10;    /**&#10;     * TEST 6 : Vérification du calcul de la méthode getValorisation() de LotStock&#10;     * Test unitaire de la méthode d'entité&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Test 6: Méthode getValorisation() de LotStock&quot;)&#10;    void testGetValorisationLotStock() {&#10;        // ARRANGE&#10;        LotStock lot = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now(), 100, 75, new BigDecimal(&quot;15.50&quot;));&#10;&#10;        // ACT&#10;        BigDecimal valorisation = lot.getValorisation();&#10;&#10;        // ASSERT&#10;        BigDecimal valorisationAttendue = new BigDecimal(&quot;1162.50&quot;); // 75 × 15.50&#10;        assertNotNull(valorisation);&#10;        assertEquals(0, valorisationAttendue.compareTo(valorisation),&#10;                &quot;La valorisation du lot doit être 1162.50 (75 × 15.50)&quot;);&#10;    }&#10;&#10;    /**&#10;     * TEST 7 : Calcul de valorisation avec prix unitaires décimaux&#10;     * Vérifie la précision des calculs avec des prix à virgule&#10;     */&#10;    @Test&#10;    @DisplayName(&quot;Test 7: Valorisation avec prix décimaux&quot;)&#10;    void testValorisationPrixDecimaux() {&#10;        // ARRANGE&#10;        // Lot 1: 33 unités × 10.33 = 340.89&#10;        LotStock lot1 = creerLot(1L, &quot;LOT-001&quot;, LocalDate.now().minusDays(20), 33, 33, new BigDecimal(&quot;10.33&quot;));&#10;        &#10;        // Lot 2: 47 unités × 15.67 = 736.49&#10;        LotStock lot2 = creerLot(2L, &quot;LOT-002&quot;, LocalDate.now().minusDays(10), 47, 47, new BigDecimal(&quot;15.67&quot;));&#10;&#10;        // Valorisation attendue = 340.89 + 736.49 = 1077.38&#10;        BigDecimal valorisationAttendue = new BigDecimal(&quot;1077.38&quot;);&#10;&#10;        when(lotStockRepository.findAll()).thenReturn(Arrays.asList(lot1, lot2));&#10;&#10;        // ACT&#10;        BigDecimal valorisation = stockService.getValorisationFifo();&#10;&#10;        // ASSERT&#10;        assertNotNull(valorisation);&#10;        assertEquals(0, valorisationAttendue.compareTo(valorisation),&#10;                &quot;La valorisation doit gérer correctement les prix décimaux (1077.38)&quot;);&#10;&#10;        verify(lotStockRepository, times(1)).findAll();&#10;    }&#10;&#10;    // ========== MÉTHODES UTILITAIRES ==========&#10;&#10;    /**&#10;     * Crée un lot de stock pour les tests&#10;     */&#10;    private LotStock creerLot(Long id, String numeroLot, LocalDate dateEntree,&#10;                              int quantiteInitiale, int quantiteRestante, BigDecimal prixUnitaire) {&#10;        return LotStock.builder()&#10;                .id(id)&#10;                .numeroLot(numeroLot)&#10;                .produit(produit)&#10;                .dateEntree(dateEntree)&#10;                .quantiteInitiale(quantiteInitiale)&#10;                .quantiteRestante(quantiteRestante)&#10;                .prixAchatUnitaire(prixUnitaire)&#10;                .build();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>